import * as vscode from "vscode";
import Timer from "./Timer";

interface DailyStats {
  date: string;
  totalTime: number;
  totalWords: number;
  totalLines: number;
  languages: Set<string>;
}

interface RankyUser {
  userId: string;
  email?: string;
  username?: string;
  [key: string]: any;
}

interface TokenPayload {
  userId: string;
  email?: string;
  username?: string;
  iat?: number;
  exp?: number;
  [key: string]: any;
}

let timer: Timer;
let inactivityTimeout: NodeJS.Timeout | undefined;
let dailyStats: DailyStats;
let isTracking = false;
let rankyUser: RankyUser | null = null;

const RANKY_AUTH_KEY = "ranky-user-auth";
const RANKY_TOKEN_KEY = "ranky-auth-token";

// JWT parsing utility (simple implementation)
function parseJWT(token: string): TokenPayload | null {
  try {
    const base64Url = token.split(".")[1];
    if (!base64Url) {
      throw new Error("Invalid token format");
    }

    const base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
    const jsonPayload = decodeURIComponent(
      atob(base64)
        .split("")
        .map((c) => "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2))
        .join("")
    );

    return JSON.parse(jsonPayload);
  } catch (error) {
    console.error("Error parsing JWT:", error);
    return null;
  }
}

async function verifyAuthWithBackend(userId: string): Promise<boolean> {
  try {
    const response = await fetch(
      "http://localhost:8000/api/v1/users/verify-extension-auth",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          secretToken: userId,
        }),
      }
    );

    if (response.ok) {
      const result = await response.json();
      return result.success === true;
    }

    return false;
  } catch (error) {
    console.error("Backend verification failed:", error);
    return false;
  }
}

async function promptForToken(): Promise<string | undefined> {
  const token = await vscode.window.showInputBox({
    prompt: "Please enter your Ranky authentication token",
    placeHolder: "Enter the token generated by Ranky website",
    password: true, // Hide the token input
    validateInput: (value: string) => {
      if (!value || value.trim().length === 0) {
        return "Token cannot be empty";
      }

      // Basic JWT format validation
      const parts = value.split(".");
      if (parts.length !== 3) {
        return "Invalid token format. Please ensure you copied the complete token.";
      }

      return null;
    },
  });

  return token?.trim();
}

async function authenticateWithToken(
  context: vscode.ExtensionContext
): Promise<RankyUser | null> {
  try {
    // Check if we already have stored auth data
    const storedUser = await context.secrets.get(RANKY_AUTH_KEY);
    const storedToken = await context.secrets.get(RANKY_TOKEN_KEY);

    if (storedUser && storedToken) {
      try {
        const userData = JSON.parse(storedUser);
        console.log("Found existing authentication data");

        // Verify the stored token is still valid
        const isValid = await verifyAuthWithBackend(userData.userId);
        if (isValid) {
          return userData;
        } else {
          console.log("Stored authentication is no longer valid, clearing...");
          await context.secrets.delete(RANKY_AUTH_KEY);
          await context.secrets.delete(RANKY_TOKEN_KEY);
        }
      } catch (error) {
        console.error("Error parsing stored user data:", error);
        await context.secrets.delete(RANKY_AUTH_KEY);
        await context.secrets.delete(RANKY_TOKEN_KEY);
      }
    }

    // Prompt for new token
    const token = await promptForToken();
    if (!token) {
      return null;
    }

    // Parse the token
    const payload = parseJWT(token);
    if (!payload || !payload.userId) {
      vscode.window.showErrorMessage(
        "Invalid token: Unable to extract user information"
      );
      return null;
    }

    console.log("Token parsed successfully, verifying with backend...");

    // Verify with backend
    const isVerified = await verifyAuthWithBackend(payload.userId);
    if (!isVerified) {
      vscode.window.showErrorMessage(
        "Authentication failed: Token verification unsuccessful"
      );
      return null;
    }

    console.log("Backend verification successful");

    // Create user object
    const userData: RankyUser = {
      userId: payload.userId,
      email: payload.email,
      username: payload.username,
    };

    // Store in VS Code secret storage
    await context.secrets.store(RANKY_AUTH_KEY, JSON.stringify(userData));
    await context.secrets.store(RANKY_TOKEN_KEY, token);

    return userData;
  } catch (error: any) {
    console.error("Token authentication failed:", error);
    vscode.window.showErrorMessage(
      `Authentication failed: ${error.message || "Unknown error occurred"}`
    );
    return null;
  }
}

async function clearAuthenticationData(context: vscode.ExtensionContext) {
  try {
    await context.secrets.delete(RANKY_AUTH_KEY);
    await context.secrets.delete(RANKY_TOKEN_KEY);
    rankyUser = null;
    console.log("Authentication data cleared");
  } catch (error) {
    console.error("Error clearing authentication data:", error);
  }
}

export async function activate(context: vscode.ExtensionContext) {
  console.log('Congratulations, your extension "ranky" is now active!');

  // Add cleanup for when extension is disposed
  context.subscriptions.push({
    dispose: () => {
      if (timer && timer.isRunning()) {
        endSession();
      }
      if (inactivityTimeout) {
        clearTimeout(inactivityTimeout);
      }
      rankyUser = null;
    },
  });

  // Add a small delay to ensure VS Code is fully loaded
  await new Promise((resolve) => setTimeout(resolve, 1000));

  try {
    rankyUser = await authenticateWithToken(context);

    if (rankyUser) {
      vscode.window.showInformationMessage(
        `‚úÖ Authenticated as ${rankyUser.username || rankyUser.userId} ${
          rankyUser.email ? `(${rankyUser.email})` : ""
        }`
      );
      console.log("Ranky user authenticated:", {
        userId: rankyUser.userId,
        username: rankyUser.username,
        email: rankyUser.email,
      });
    } else {
      vscode.window.showWarningMessage("‚ùå Ranky Authentication failed.");
      vscode.window.showInformationMessage(
        "Extension loaded without authentication. Use 'Ranky: Refresh Auth' command to authenticate later."
      );
    }
  } catch (error) {
    console.error("Authentication error during activation:", error);
    vscode.window.showErrorMessage(
      "Failed to authenticate during extension startup. You can retry using the 'Ranky: Refresh Auth' command."
    );
  }

  timer = new Timer();
  initializeDailyStats();

  const textChangeDisposable = vscode.workspace.onDidChangeTextDocument((e) => {
    if (e.contentChanges && e.contentChanges.length > 0) {
      handleUserCoding(e);
    }
  });

  const showStatsCommand = vscode.commands.registerCommand(
    "ranky.showStats",
    () => {
      showCurrentStats();
    }
  );

  // Command to refresh Ranky authentication
  const refreshAuthCommand = vscode.commands.registerCommand(
    "ranky.refreshAuth",
    async () => {
      try {
        vscode.window.showInformationMessage(
          "Attempting to refresh Ranky authentication..."
        );

        // Clear existing auth data
        await clearAuthenticationData(context);

        rankyUser = await authenticateWithToken(context);
        if (rankyUser) {
          vscode.window.showInformationMessage(
            `‚úÖ Re-authenticated as ${rankyUser.username || rankyUser.userId} ${
              rankyUser.email ? `(${rankyUser.email})` : ""
            }`
          );
        } else {
          vscode.window.showErrorMessage(
            "‚ùå Authentication failed. Please check your token and try again."
          );
        }
      } catch (error) {
        console.error("Manual authentication failed:", error);
        vscode.window.showErrorMessage(
          "Authentication failed. Please check your token and try again."
        );
      }
    }
  );

  // Command to clear authentication data
  const clearAuthCommand = vscode.commands.registerCommand(
    "ranky.clearAuth",
    async () => {
      try {
        await clearAuthenticationData(context);
        vscode.window.showInformationMessage(
          "Authentication data cleared. Use 'Ranky: Refresh Auth' to re-authenticate."
        );
      } catch (error) {
        console.error("Error clearing authentication:", error);
        vscode.window.showErrorMessage("Failed to clear authentication data.");
      }
    }
  );

  // Command to manually enter token (useful if user wants to change token)
  const enterTokenCommand = vscode.commands.registerCommand(
    "ranky.enterToken",
    async () => {
      try {
        await clearAuthenticationData(context);
        rankyUser = await authenticateWithToken(context);

        if (rankyUser) {
          vscode.window.showInformationMessage(
            `‚úÖ Successfully authenticated with new token`
          );
        }
      } catch (error) {
        console.error("Token entry failed:", error);
        vscode.window.showErrorMessage(
          "Failed to authenticate with the provided token."
        );
      }
    }
  );

  context.subscriptions.push(
    textChangeDisposable,
    showStatsCommand,
    refreshAuthCommand,
    clearAuthCommand,
    enterTokenCommand
  );
}

function initializeDailyStats() {
  const today = new Date().toISOString().split("T")[0];
  dailyStats = {
    date: today,
    totalTime: 0,
    totalWords: 0,
    totalLines: 0,
    languages: new Set<string>(),
  };
}

function handleUserCoding(e: vscode.TextDocumentChangeEvent) {
  const editor = vscode.window.activeTextEditor;
  if (!editor || !e.document) {
    return;
  }

  const language = e.document.languageId;
  dailyStats.languages.add(language);

  if (inactivityTimeout) {
    clearTimeout(inactivityTimeout);
  }

  if (!timer.isRunning()) {
    timer.start();
    isTracking = true;
    console.log("Started tracking coding session");
  }

  e.contentChanges.forEach((change) => {
    const newLines = (change.text.match(/\n/g) || []).length;
    if (newLines > 0) {
      dailyStats.totalLines += newLines;
    }

    if (change.text.length > 0 && change.rangeLength === 0) {
      const hasContent = change.text.trim().length > 0;
      if (hasContent && !change.text.includes("\n")) {
        const words = change.text
          .trim()
          .split(/\s+/)
          .filter((w) => w.length > 0);
        dailyStats.totalWords += words.length;
      }
    }
  });

  inactivityTimeout = setTimeout(() => {
    endSession();
    console.log("Session ended due to 2 minutes of inactivity");
  }, 120000);
}

function endSession() {
  if (timer.isRunning()) {
    const sessionTime = timer.getElapsedSeconds();
    dailyStats.totalTime += sessionTime;
    timer.stop();
    isTracking = false;
    console.log(`Session ended: ${Math.round(sessionTime)}s`);
  }

  if (inactivityTimeout) {
    clearTimeout(inactivityTimeout);
    inactivityTimeout = undefined;
  }
}

function showCurrentStats() {
  const currentSessionTime = timer.isRunning() ? timer.getElapsedSeconds() : 0;
  const totalTime = dailyStats.totalTime + currentSessionTime;

  let statsMessage = `üìä Today's Coding Stats:\n`;
  statsMessage += `üë§ User: ${
    rankyUser?.username || rankyUser?.userId || "Unknown"
  }\n`;
  statsMessage += `‚è±Ô∏è Total Time: ${Math.round(totalTime)}s (${(
    totalTime / 60
  ).toFixed(1)}min)\n`;
  statsMessage += `üìù Total Words: ${dailyStats.totalWords}\n`;
  statsMessage += `üìÑ Total Lines: ${dailyStats.totalLines}\n`;
  statsMessage += `üöÄ Languages: ${Array.from(dailyStats.languages).join(
    ", "
  )}\n`;

  vscode.window.showInformationMessage(statsMessage);
}

export async function deactivate() {}
